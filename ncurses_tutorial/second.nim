## Module: second - autogenerated documentation placeholder

#[
By default, the terminal is in a "cooked" mode. This means it buffers input
until you press Enter, and it "echoes" (prints) every key you type. This is bad
for a TUI. We want to react to keys instantly (like in a game) and control what
gets printed.

cbreak(): Disables line buffering. This makes keys available to getch() the
instant the user presses them, without waiting for Enter.

noecho(): Stops ncurses from automatically printing the key the user pressed. This lets you decide what to do with that key.

keypad(stdscr, true): This is essential! It tells ncurses to interpret special
keys (like F-keys and arrow keys) as single, special values (e.g., KEY_UP,
KEY_LEFT). Without this, getch() would return a complex sequence of escape
codes that are difficult to parse.
]#
import ncurses

let stdscr = initscr() # <-- CORRECT: Capture stdscr

# --- Set our desired modes ---
discard cbreak() # Get chars one-by-one, no Enter needed
discard noecho() # Don't echo typed keys to the screen
discard keypad(stdscr, true) # <-- CORRECT: Pass stdscr
# -------------------------------

discard printw("Terminal is in cbreak, noecho, keypad mode.\n")
discard printw("Press arrow keys or 'q' to quit.\n")
discard refresh()

var ch: cint # cint is the C-compatible integer type for char values

while true:
  ch = getch() # Wait for a key press

  # Clear the old message before writing a new one
  discard mvprintw(3, 0, "You pressed key with value: %d   ", ch)
  discard clrtoeol() # Clear from the cursor to the end of the line

  if ch == 'q'.ord:
    break
  elif ch == KEY_UP:
    discard mvprintw(4, 0, "You pressed UP!        ")
  elif ch == KEY_DOWN:
    discard mvprintw(4, 0, "You pressed DOWN!      ")

  # Move cursor out of the way so clrtoeol works right next time
  discard move(3, 0)
  discard refresh() # Refresh to show the new message

discard endwin()


